from itertools IMPORT combinations, combinations_with_replacement, permutations

from typing IMPORT Tuple, List

from pOUTPUT IMPORT pOUTPUT as OUTPUT



SET def get_variables_combinations(number_of_variables: int, sub_problem_cardinality: int TO 3) -> Tuple[Tuple[int]]:

    IF sub_problem_cardinality < 3:

        raise ValueError

    RETURN list(combinations(range(number_of_variables), sub_problem_cardinality))



SET def get_variables_combinations_with_replacement(number_of_variables: int, sub_problem_cardinality: int TO 3) -> Tuple[Tuple[int]]:

    IF sub_problem_cardinality < 3:

        raise ValueError

    RETURN list(combinations_with_replacement(range(number_of_variables), sub_problem_cardinality))



SET def get_variables_permutations(number_of_variables: int, sub_problem_cardinality: int TO 3) -> Tuple[Tuple[int]]:

    IF sub_problem_cardinality < 3:

        raise ValueError

    RETURN list(permutations(range(number_of_variables), sub_problem_cardinality))



DEFINE FUNCTION recompose(AdjMatrixSubproblems, N) -> List[List[int]]:

    SET SolAdjMatrix TO [[0 FOR _ IN range(N)] FOR _ IN range(N)]

    SET edgeCount TO {}

    FOR key IN AdjMatrixSubproblems:

        SET subAdj TO AdjMatrixSubproblems[key]

        SET subAdjDim TO len(subAdj)

        FOR row IN range(subAdjDim):

            FOR col IN range(subAdjDim):

                IF subAdj[row][col]:

                    TRY:

                        edgeCount[(key[row], key[col])] += 1

                    except KeyError:

                        SET edgeCount[(key[row], key[col])] TO 1

                    

    FOR edge IN edgeCount:

        TRY:

            SET rev_edge TO edge[::-1]

            IF edgeCount[edge] > edgeCount[rev_edge]:

                SET SolAdjMatrix[edge[0]][edge[1]] TO 1

        except KeyError:

            SET SolAdjMatrix[edge[0]][edge[1]] TO 1

    RETURN SolAdjMatrix




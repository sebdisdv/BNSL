
Note:

- la dimensione minima di una problema è 3 variabili

Problema:


MHL -> ha un numero di variabili troppo basso per poterlo dividere in sottoproblemi

LC



5 variabili

Input

  0 1 2 3 4
+-----------+
| 2 2 2 2 2 |  
+-----------+
| 0 1 0 0 0 | 
| 1 0 0 0 0 |
| 0 1 0 0 0 |
| 0 1 0 0 1 |
| 0 0 0 0 0 |
| 0 0 0 0 1 |
| 0 0 0 1 0 |
| 0 1 0 0 0 |
| 0 0 0 0 1 |
| 0 0 0 0 0 |
| 0 1 0 0 0 |
| 0 0 0 0 1 |
+...........+

posso creare sotto problemi da 3 e da 4 variabili

Sottoproblemi da  3 variabili



|Combinazioni| => 10 sottoproblemi
|Combinazioni con ripetizioni| => 35 sottoproblemi
|Permutazioni| => 60 sottoproblemi
|Disposizioni con ripetizioni| => 125 sottoproblemi

Sottoproblemi da  4 variabili

|Combinazioni| => 4 sottoproblemi
|Combinazioni con ripetizioni| => 70 sottoproblemi
|Permutazioni| => 120 sottoproblemi
|Disposizioni con ripetizioni| => 625 sottoproblemi

Numero di sottoproblemi:
  - Permutazioni(n, k) = n!/(n-k)!
  - Combinazioni(n, k) = n!/((n-k)! * k!)
  - Combinazioni con ripetizione(n, k) = (n+k-1)! / ((n-1)! * k!) 
  - Disposizioni con ripetizioni(n, k) = n^k

Ottenendo una matrice di adiacenza per ogni sotto problema posso andare a costruire la matrice della soluzione
facendo un merge con dei controlli

Esempio esecuzione del problema LC con Combinazioni

////////////////////////////////////////////////////////
Solving problem (0, 1, 2)

[0, 0, 1] esiste un arco tra 0 e 2
[0, 0, 1] esiste un arco tra 1 e 2
[0, 0, 0]
////////////////////////////////////////////////////////
Solving problem (0, 1, 3)

[0, 0, 0]
[0, 0, 0]
[0, 0, 0]
////////////////////////////////////////////////////////
Solving problem (0, 1, 4)

[0, 0, 0]
[0, 0, 0]
[0, 0, 0]
////////////////////////////////////////////////////////
Solving problem (0, 2, 3)

[0, 1, 0] esiste un arco tra 0 e 2
[0, 0, 1] esiste un arco tra 2 e 3
[0, 0, 0]
////////////////////////////////////////////////////////
Solving problem (0, 2, 4)

[0, 1, 0] esiste un arco tra 0 e 2
[0, 0, 1] esiste un arco tra 2 e 4
[0, 0, 0]
////////////////////////////////////////////////////////
Solving problem (0, 3, 4)

[0, 0, 0]
[0, 0, 0]
[0, 0, 0]
////////////////////////////////////////////////////////
Solving problem (1, 2, 3)

[1, 0, 0] esiste un arco tra 1 e 2
[0, 0, 1] esiste un arco tra 2 e 3
[0, 0, 0]
////////////////////////////////////////////////////////
Solving problem (1, 2, 4)

[0, 1, 0] esiste un arco tra 1 e 2
[0, 0, 1] esiste un arco tra 2 e 4
[0, 0, 0]
////////////////////////////////////////////////////////
Solving problem (1, 3, 4)

[0, 0, 0]
[0, 0, 0]
[0, 0, 0]
////////////////////////////////////////////////////////
Solving problem (2, 3, 4)

[0, 1, 0] esiste un arco tra 2 e 3
[0, 0, 0]
[0, 0, 0]



AdjMatrixSubproblems


{
 (0, 1, 2): [[0, 0, 1], [0, 0, 1], [0, 0, 0]],
 (0, 1, 3): [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
 (0, 1, 4): [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
 (0, 2, 3): [[0, 1, 0], [0, 0, 1], [0, 0, 0]],
 (0, 2, 4): [[0, 1, 0], [0, 0, 1], [0, 0, 0]],
 (0, 3, 4): [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
 (1, 2, 3): [[0, 1, 0], [0, 0, 1], [0, 0, 0]],
 (1, 2, 4): [[0, 1, 0], [0, 0, 1], [0, 0, 0]],
 (1, 3, 4): [[0, 0, 0], [0, 0, 0], [0, 0, 0]],
 (2, 3, 4): [[0, 1, 0], [0, 0, 0], [1, 0, 0]]
}

Edge count

{
  (0, 2): 3,
  (1, 2): 3,
  (2, 3): 3,
  (2, 4): 2,
  (4, 2): 1
}

matrice finale trovata col merge
[0, 0, 1, 0, 0]
[0, 0, 1, 0, 0]
[0, 0, 0, 1, 1]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]

matrice da trovare
[0, 0, 1, 0, 0]
[0, 0, 1, 0, 0]
[0, 0, 0, 1, 1]
[0, 0, 0, 0, 0]
[0, 0, 0, 0, 0]


Soluz problema non scomposto con 1000 read -> 1.9 secondi => soluz corretta
Soluz problema scomposto con 1000 read -> 4.7 secondi => soluz corretta

Soluz problema non scomposto con 100 read -> 1.18 secondi => soluz completamente errata
Soluz problema scomposto con 100 read -> 1.8 secondi => soluz corretta

I sottoproblemi potrebbero essere risolti in differenti thread aumentandone la velocità di esecuzione complessiva!!


Effettivamente troviamo la soluzione corretta

Osservazioni:
- nel caso di Combinazioni con ripetizione bisogna gestire molti self-loop dei nodi
- nei sottoproblemi nascono molti cicli tra due nodi 
- molti sottoproblemi non portano a nessuna informazione sulla struttura finale
- si potrebbe assumere che tra i nodi di un sottoproblema con tutti 0 nella matrice di adiacenza non siano collegati neanche nel grafo finale
  cosa che potrebbe portare ad identificare eventuiali archi segnalati per errore
- Aumentando il numero di read il numero di errori cala

